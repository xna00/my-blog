<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>博客</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.79.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    

  
  
    <link rel="stylesheet" href="/my-blog/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css" >
  




    
      

    

    
    
      <link href="/my-blog/posts/index.xml" rel="alternate" type="application/rss+xml" title="博客" />
      <link href="/my-blog/posts/index.xml" rel="feed" type="application/rss+xml" title="博客" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://xna00.github.io/my-blog/posts/" />
<meta property="og:updated_time" content="2020-12-29T12:51:29+08:00" />
<meta itemprop="name" content="Posts">
<meta itemprop="description" content="">
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/my-blog/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        博客
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xna00.github.io/my-blog/posts/javascript%E7%9A%84%E6%95%85%E4%BA%8B/" class="link black dim">
        JavaScript的故事.md
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JavaScript 历史 肇始于网景 1993年，伊利诺伊大学厄巴纳-尚佩恩分校的国家超级电脑应用中心（NCSA）发表了NCSA Mosaic，这是最早流行的图形接口网页浏览器，它在万维网的普及上发挥了重要作用。1994年，一家名为Mosaic Communications的公司在加州芒廷维尤成立了，并雇用了许多原来的NCSA Mosaic开发者用来开发Mosaic Netscape，该公司的目标是取代NCSA Mosaic成为世界第一的网页浏览器。第一个版本的网页浏览器Mosaic Netscape 0.9于1994年底发布。在四个月内，已经占据了四分之三的浏览器市场，并成为1990年代互联网的主要浏览器。为避免NCSA的商标所有权问题，该浏览器于同年更名为Netscape Navigator，该公司命名为Netscape Communications。网景预见到网络需要变得更动态。公司的创始人马克·安德森认为HTML需要一种胶水语言，让网页设计师和兼职程序员可以很容易地使用它来组装图片和插件之类的组件，且代码可以直接编写在网页标记中。
1995年，网景招募了布兰登·艾克，目标是把Scheme语言嵌入到Netscape Navigator浏览器当中。但更早之前，网景已经跟昇阳合作在Netscape Navigator中支持Java，这时网景内部产生激烈的争论。后来网景决定发明一种与Java搭配使用的辅助脚本语言并且语法上有些类似，这个决策导致排除了采用现有的语言，例如Perl、Python、Tcl或Scheme。为了在其他竞争提案中捍卫JavaScript这个想法，公司需要有一个可以运作的原型。艾克在1995年5月仅花了十天时间就把原型设计出来了。
最初命名为Mocha，1995年9月在Netscape Navigator 2.0的Beta版中改名为LiveScript，同年12月，Netscape Navigator 2.0 Beta 3中部署时被重命名为JavaScript，当时网景公司与昇阳电脑公司组成的开发联盟为了让这门语言搭上Java这个编程语言“热词”，因此将其临时改名为JavaScript，日后这成为大众对这门语言有诸多误解的原因之一。
微软采纳 JavaScript推出后在浏览器上大获成功，微软公司在不久后就为Internet Explorer 3浏览器推出了JScript，以与处于市场领导地位的网景产品同台竞争。JScript也是一种JavaScript实现，这两个JavaScript语言版本在浏览器端共存意味着语言标准化的缺失，发展初期，JavaScript的标准并未确定，同期有网景的JavaScript，微软的JScript双峰并峙。除此之外，微软也在网页技术上加入了不少专属对象，使不少网页使用非微软平台及浏览器无法正常显示，导致在浏览器大战期间网页设计者通常会把“用Netscape可达到最佳效果”或“用IE可达到最佳效果”的标志放在主页。随着Internet Explorer 4的发布，微软引入了动态HTML的概念，但语言实现和不同专有化的文档对象模型的差异仍然存在，成为网络上普及使用JavaScript的阻碍。
标准化 1996年11月，网景正式向ECMA（欧洲计算机制造商协会）提交语言标准。1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262。JavaScript成为了ECMAScript最著名的实现之一。除此之外，ActionScript和JScript也都是ECMAScript规范的实现语言。尽管JavaScript作为给非程序人员的脚本语言，而非作为给程序人员的脚本语言来推广和宣传，但是JavaScript具有非常丰富的特性。
缺陷   不适合开发大型程序
  非常小的标准库
  null和undefined
  全局变量难以控制
  自动插入行尾分号
  比如，下面这个函数根本无法达到预期的结果，返回值不是一个对象，而是undefined。
 　function(){
　return { i=1 };
　}
 原因是解释器自动在return语句后面加上了分号。
 　function(){
　return; { i=1 };
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xna00.github.io/my-blog/posts/jquery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" class="link black dim">
        jQuery设计思想.md
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      jQuery设计思想 一、选择网页元素 CSS选择器 $(document) //选择整个文档对象  $(&#39;#myId&#39;) //选择ID为myId的网页元素  $(&#39;div.myClass&#39;) // 选择class为myClass的div元素  $(&#39;input[name=first]&#39;) // 选择name属性等于first的input元素 jQuery特有的表达式 $(&#39;a:first&#39;) //选择网页中第一个a元素  $(&#39;tr:odd&#39;) //选择表格的奇数行  $(&#39;#myForm :input&#39;) // 选择表单中的input元素  $(&#39;div:visible&#39;) //选择可见的div元素  $(&#39;div:gt(2)&#39;) // 选择所有的div元素，除了前三个  $(&#39;div:animated&#39;) // 选择当前处于动画状态的div元素 二、改变结果集 $(&#39;div&#39;).has(&#39;p&#39;); // 选择包含p元素的div元素  $(&#39;div&#39;).not(&#39;.myClass&#39;); //选择class不等于myClass的div元素  $(&#39;div&#39;).filter(&#39;.myClass&#39;); //选择class等于myClass的div元素  $(&#39;div&#39;).first(); //选择第1个div元素  $(&#39;div&#39;).eq(5); //选择第6个div元素 $(&#39;div&#39;).next(&#39;p&#39;); //选择div元素后面的第一个p元素  $(&#39;div&#39;).parent(); //选择div元素的父元素  $(&#39;div&#39;).closest(&#39;form&#39;); //选择离div最近的那个form父元素  $(&#39;div&#39;).children(); //选择div的所有子元素  $(&#39;div&#39;).siblings(); //选择div的同级元素 三、链式操作 $(&#39;div&#39;) //找到div元素  .
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xna00.github.io/my-blog/posts/js-%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" class="link black dim">
        JS 对象基本用法.md
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JS 对象基本用法 对象的属性名是字符串，有时候可以省略引号。
声明对象  obj = {} 使用Object构造  删除对象的属性 delete obj.xxx
查看对象的属性  obj.xxx obj[&lsquo;xxx&rsquo;] obj[name] 要对name求值 Object.keys(obj) console.dir(obj)  修改或增加对象的属性  直接赋值 批量赋值 Object.assign()  如果要修的属性不存在，就增加属性。
&lsquo;name&rsquo; in obj和obj.hasOwnProperty(&lsquo;name&rsquo;)  &lsquo;name&rsquo; in obj 包括原型里的属性 obj.hasOwnProperty(&lsquo;name&rsquo;) 不包括原型里的属性  
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xna00.github.io/my-blog/posts/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/" class="link black dim">
        JS函数的执行时机.md
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JS函数的执行时机 一、6个6 let i = 0 for(i = 0; i&lt;6; i++){ setTimeout(()=&gt;{ console.log(i) },0) } 以上代码会打印出6个6，因为console.log会在for循环结束后执行，此时i的值是6
二、打印0、1、2、3、4、5 for(let i = 0; i&lt;6; i++){ setTimeout(()=&gt;{ console.log(i) },0) } 以上代码会打印出0、1、2、3、4、5。i是在for里面声明的，有块级作用域。每次循环都会创建一个新的i。
三、另一个打印0、1、2、3、4、5的方法 let i = 0 for(i = 0; i&lt;6; i++){ !function() { let j = i; setTimeout(() =&gt; { console.log(j) },0) }() } 
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xna00.github.io/my-blog/posts/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="link black dim">
        JS的基本语法.md
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JS的基本语法 表达式和语句  表达式一般有值 语句可能有值，也可能没有 并不绝对  标识符 第一个字符，可以是Unicode字母或$或_或 中文。之后的字符，还可以是数字。
if else 两种比较好的写法
  if (表达式) { 语句 } else if (表达式) { 语句 } else { 语句 }   function fn(){ if ( ) { return } if ( ) { return } return }   switch switch (fruit) { case &#34;banana&#34;: // ...  break; case &#34;apple&#34;: // ...  break; default: // ... } 循环语句 while(表达式) { } for(语句1; 表达式2; 语句3){ }  break跳出最近的一层循环 continue跳过当前的这次循环  label foo: { console.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xna00.github.io/my-blog/posts/vue%E5%AE%89%E8%A3%85/" class="link black dim">
        Vue安装.md
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Vue安装 安装 点击
Vue的两个版本 Vue的编译器，用来将模板字符串编译成为 JavaScript 渲染函数的代码。
 完整版，vue.js，同时包含编译器和运行时的版本。 只包含运行时版，vue.runtime.js，用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。  运行时 + 编译器 vs. 只包含运行时 如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版：
// 需要编译器 new Vue({ template: &#39;&lt;div&gt;{{ hi }}&lt;/div&gt;&#39; }) // 不需要编译器 new Vue({ render (h) { return h(&#39;div&#39;, this.hi) } }) 当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。
因为运行时版本相比完整版体积要小大约 30%，所以应该尽可能使用这个版本。如果仍然希望使用完整版，则需要在打包工具里配置一个别名：
webpack module.exports = { // ... resolve: { alias: { 'vue$': 'vue/dist/vue.esm.js' // 用 webpack 1 时需用 'vue/dist/vue.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xna00.github.io/my-blog/posts/%E6%B5%85%E6%9E%90mvc/" class="link black dim">
        浅析MVC.md
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      浅析MVC M V C  模型（Model） 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。“ Model ”有对数据直接访问的权力，例如对数据库的访问。“Model”不依赖“View”和“Controller”，也就是说， Model 不关心它会被如何显示或是如何被操作。但是 Model 中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变。 **视图（View）**能够实现数据有目的的显示（理论上，这不是必需的）。在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，View 需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。 **控制器（Controller）**起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。“事件”包括用户的行为和数据 Model 上的改变。  一个通过 JavaScript所实现的基于 MVC 模型
/** 模擬 Model, View, Controller */ var M = {}, V = {}, C = {}; /** Model 負責存放資料 */ M.data = &#34;hello world&#34;; /** View 負責將資料輸出到螢幕上 */ V.render = (M) =&gt; { alert(M.data); } /** Controller 作為一個 M 和 V 的橋樑 */ C.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xna00.github.io/my-blog/posts/%E6%B5%85%E6%9E%90url/" class="link black dim">
        浅析URL.md
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      浅析URL URL的组成 URL，Uniform Resource Locator，统一资源定位器
 协议 域名或IP 端口号 路径 查询字符串 锚点，锚点不会发送给服务器！  DNS DNS，Domain Name System，域名系统，将域名转换为IP
可以使用nslook 域名查询
IP IP用来定位一台计算机
ping IP/域名
域名  com是顶级域名 xxxx.com是二级域名，俗称一级域名 yyyy.xxxx.com是三集域名，俗称二级域名  
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xna00.github.io/my-blog/posts/%E8%99%9A%E6%8B%9F-dom-%E5%92%8C-dom-diff/" class="link black dim">
        虚拟 DOM 和 DOM diff.md
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      虚拟 DOM 和 DOM diff 虚拟 DOM 是什么 虚拟dom，与真实dom相对，是JS对象
虚拟DOM的优点 在某些情况下，dom操作的速度较快
 将多次操作合并为一次，如添加1000个节点 借助DOM diff将多余的操作省去，如添加1000个节点，但只有10个是新增的  虚拟DOM的缺点 在大量DOM操作时，会造成卡顿，因为进行的额外计算太多了
DOM diff是什么 DOM diff是虚拟DOM的对比算法
DOM diff的优点 通过DOM diff，可以简化DOM操作
DOM diff的问题 DOM diff的算法可能有Bug,Vue key的作用
    </div>
  </div>
</div>
</div>
      
    </section>
<ul class="pagination">
  <li class="page-item">
    <a href="/my-blog/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/my-blog/posts/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/my-blog/posts/">1</a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="/my-blog/posts/page/2/">2</a>
  </li>
  <li class="page-item disabled">
    <a  class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/my-blog/posts/page/2/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xna00.github.io/my-blog" >
    &copy;  博客 2021 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
